-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package hstlink
@version 0.1.0.0


-- | This module can detect attached STLink dongles, and has some fnuctions
--   for pretty-printing a table of detected devices, as well as prompting
--   the user to select one if more than one is found.
module STLink.Detection

-- | Ask the user to select one of the available board, or fail if none are
--   available.
pickBoard :: IO (Maybe Device)


-- | Most users shouldn't have to import this module, since the important
--   bits are re-exported elsewhere.
module STLink.Driver

-- | Low-level command that formats an "inward" command the way the STLink
--   dongle likes it:
--   
--   <pre>
--   USB_BULK out &lt;up to 16 bytes of commands&gt;
--   USB_BULK in &lt;expected response length&gt;
--   </pre>
--   
--   Since USB is a host-oriented protocol, we have to know in advance how
--   many bytes to read from the device's buffer.
inCommand :: DeviceHandle -> ByteString -> Size -> ExceptT String IO ByteString

-- | Low-level command that formats an "outward" command the way the STLink
--   dongle likes it:
--   
--   <pre>
--   USB_BULK out &lt;up to 16 bytes of commands&gt;
--   USB_BULK out &lt;outward-bound data&gt;
--   </pre>
outCommand :: DeviceHandle -> ByteString -> ByteString -> ExceptT String IO ()

-- | Automatically finds a board (and prompts the user to select one if
--   several are attached) and then runs the <a>STLink</a> action with that
--   board.
withAutoBoard :: STLink a -> IO (Maybe a)

-- | Lets the user manually specify a USB <a>Device</a> to execute the
--   <a>STLink</a> action on.
withBoard :: Device -> STLink a -> IO (Maybe a)

-- | This monad lets you write effectful computations that communicate with
--   an STLink dongle, without explicitly specifying the dongle you want to
--   talk with for every command. Generally, 'runSTLink wouldn't be used
--   directly since it takes a low-level <a>DeviceHandle</a> instead of a
--   general <a>Device</a>. See <a>withBoard</a> for a safe, high-level way
--   to run an <a>STLink</a>.
newtype STLink a
STLink :: (DeviceHandle -> ExceptT String IO a) -> STLink a
instance GHC.Base.Functor STLink.Driver.STLink
instance GHC.Base.Applicative STLink.Driver.STLink
instance GHC.Base.Monad STLink.Driver.STLink
instance Control.Monad.IO.Class.MonadIO STLink.Driver.STLink


-- | All the raw commands that an STLink dongle understands can be found
--   here, though high-level wrappers for them are elsewhere.
module STLink.Commands

-- | Get the version of an STLink dongle.
getVersion :: STLink ResponseVersion

-- | The STLink version reported by the dongle. The response also contians
--   the VID and PID of the USB interface, but this is ignored since it is
--   redundant.
data ResponseVersion
ResponseVersion :: Int -> Int -> Int -> ResponseVersion

-- | The STLink protocol version this dongle understands.
[versionStlink] :: ResponseVersion -> Int

-- | Which JTAG revision the dongle is capable of.
[versionJtag] :: ResponseVersion -> Int

-- | Purpose unclear.
[versionSwim] :: ResponseVersion -> Int

-- | Figure out what major mode the STLink dongle is operating in. (Debug
--   or otherwise.)
getCurrentMode :: STLink STLinkMode

-- | Major mode for STLink, rather than the minor debug mode
--   (<a>DebugMode</a>).
data STLinkMode
ModeDFU :: STLinkMode
ModeMass :: STLinkMode
ModeDebug :: STLinkMode
ModeSWIM :: STLinkMode
ModeBootloader :: STLinkMode

-- | Get the voltage on the output of the STLink regulator. (Should be
--   ~3.3V).
getCurrentVoltage :: STLink Float

-- | Leave either DFU or Mass mode and enter one of the three debug modes.
enterMode :: DebugMode -> STLink ()

-- | Which debugging interface the dongle with interface with. Prefer SWD
--   when possible.
data DebugMode
DebugJTAG :: DebugMode
DebugSWD :: DebugMode
DebugSWIM :: DebugMode

-- | Get the current state of the CPU. You must be in SWD or JTAG mode to
--   issue this command.
getStatus :: STLink DebugStatus

-- | Determines if the CPU is running or halted (through debug commands).
data DebugStatus

-- | Stop execution on the microcontroller.
haltCore :: STLink ()

-- | Continue execution on the microcontroller.
runCore :: STLink ()

-- | Step one instruction on the microcontroller.
stepCore :: STLink ()

-- | Reset the microcontroller.
resetCore :: STLink ()

-- | Read the specified real register. (Debug registers are not accessible
--   through this command).
readReg :: Reg -> STLink Word32

-- | Write a <a>Word32</a> to the specified <a>Reg</a>.
writeReg :: Reg -> Word32 -> STLink ()

-- | Peeks <tt>l</tt> bytes of memory at address <tt>a</tt>.
--   
--   A maximum of 64 bytes can be read in one command.
readMem :: Word32 -> Word16 -> STLink ByteString

-- | Writes a <a>ByteString</a> into the location in memory specified by
--   <tt>a</tt>.
--   
--   A maximum of 64 bytes can be written in one command.
writeMem :: Word32 -> ByteString -> STLink ()
instance GHC.Show.Show STLink.Commands.CommandWriteMem
instance GHC.Classes.Eq STLink.Commands.CommandWriteMem
instance GHC.Show.Show STLink.Commands.CommandReadMem
instance GHC.Classes.Eq STLink.Commands.CommandReadMem
instance GHC.Show.Show STLink.Commands.CommandReadReg
instance GHC.Classes.Eq STLink.Commands.CommandReadReg
instance GHC.Show.Show STLink.Commands.CommandExecution
instance GHC.Classes.Eq STLink.Commands.CommandExecution
instance GHC.Classes.Eq STLink.Commands.DebugStatus
instance GHC.Show.Show STLink.Commands.DebugStatus
instance GHC.Classes.Eq STLink.Commands.CommandGetStatus
instance GHC.Show.Show STLink.Commands.CommandGetStatus
instance GHC.Classes.Eq STLink.Commands.CommandModeEnter
instance GHC.Show.Show STLink.Commands.CommandModeEnter
instance GHC.Classes.Eq STLink.Commands.DebugMode
instance GHC.Show.Show STLink.Commands.DebugMode
instance GHC.Classes.Eq STLink.Commands.CommandGetVoltage
instance GHC.Show.Show STLink.Commands.CommandGetVoltage
instance GHC.Classes.Eq STLink.Commands.STLinkMode
instance GHC.Show.Show STLink.Commands.STLinkMode
instance GHC.Classes.Eq STLink.Commands.CommandGetMode
instance GHC.Show.Show STLink.Commands.CommandGetMode
instance GHC.Classes.Eq STLink.Commands.ResponseVersion
instance GHC.Show.Show STLink.Commands.ResponseVersion
instance GHC.Classes.Eq STLink.Commands.CommandVersion
instance GHC.Show.Show STLink.Commands.CommandVersion
instance STLink.Commands.OutCommand STLink.Commands.CommandWriteMem
instance STLink.Commands.InCommand STLink.Commands.CommandReadMem
instance STLink.Commands.InCommand STLink.Commands.CommandWriteReg
instance STLink.Commands.InCommand STLink.Commands.CommandReadReg
instance STLink.Commands.InCommand STLink.Commands.CommandExecution
instance STLink.Commands.InCommand STLink.Commands.CommandGetStatus
instance STLink.Commands.InCommand STLink.Commands.CommandModeEnter
instance STLink.Commands.InCommand STLink.Commands.CommandGetVoltage
instance STLink.Commands.InCommand STLink.Commands.CommandGetMode
instance STLink.Commands.InCommand STLink.Commands.CommandVersion


-- | This is the module users should import when writing applications.
--   
--   <h1>Short Tutorial</h1>
--   
--   Interacting with an STLink board is really easy! All STLink-board
--   related actions run inside the <a>STLink</a> monad. For example, we
--   can read <tt>r0</tt>, and then write its value + 3 back into
--   <tt>r1</tt>. <tt>0x1234</tt>:
--   
--   <pre>
--   myAction :: STLink ()
--   myAction = do
--     enterMode DebugSWD -- must be in debug mode to peek/poke registers
--     num &lt;- readReg 0
--     writeReg 1 (num + 3)
--   </pre>
--   
--   <a>STLink</a> actions are board-agnostic, so in order to run them you
--   have to use the <a>withBoard</a> function, that will automatically
--   connect and disconnect to the board. It takes any STLink action, as
--   well as a USB <tt>Device</tt>, and runs that action on that device.
--   
--   In order to make things simpler, a helper function
--   <a>withAutoBoard</a> is provided, that will scan for attached STLink
--   dongles, and automatically run the given action if one is available.
--   If more than one is connected, a menu will prompt the user to select
--   the desired one. We can use this to run our <tt>myAction</tt>
--   <a>STLink</a> action:
--   
--   <pre>
--   main :: IO ()
--   main = withAutoBoard myAction
--   </pre>
module STLink
